#summary osgi-samples/hibernate explained

= Introduction =

osgi-samples/hibernate demonstrates how to use Hibernate in OSGi with Spring Framework and Spring-DM.

The solution is roughly based on this [http://www.osgi.org/blog/labels/osgi%20hibernate%20felix%20equinox%20eclipse%20knopflerfish%20sql.html  OSGi and Hibernate blog entry] by Peter Kriens.
Peter's design uses a declaration in the manifest file to declaratively add classes to the Hibernate session using an _extender model_.  In our implementation however, we currently do not use the extender model but instead explicitly add new classes to the Hibernate session through a bundle activator.

== Get the code ==

To get the source code for the hibernate sample, use SVN:

svn checkout http://voluble.googlecode.com/svn/trunk/osgi-samples/hibernate/ osgi-hibernate-sample

== Run the code ==

You should then be able to run "mvn install" in the new osgi-hibernate-sample folder and see all projects build successfully.  

  _At the moment you need to first manually start a HSQLDB database before the tests will run.  After downloading a hsqldb.jar, you can start the database from the command line using:_

{{{
 java -cp hsqldb.jar org.hsqldb.Server -database.0 file:osgi-hibernate-sample.db -dbname.0 osgi-hibernate-sample
}}}

  (Hopefully this is temporary and we'll soon change the code to start the database automatically)

== Understanding the code ==

The implementation demonstrates how OSGi bundles can dynamically add new classes to a Hibernate configuration.  We start with a bundle that provides a Hibernate SessionFactory - other bundles can grab and use the SessionFactory to access a database.  However, if a new bundle is installed and it defines new entity classes that was not in the SessionFactory configuration when it was created, then the SessionFactory must be recreated to update the configuration with the new classes.

To make this pattern work, the Hibernate SessionFactory should not be accessed directly.  Instead, the it should be accessed via a proxy which ensures that a SessionFactory with the most up to date configuration is always used.  Using Spring Framework, this implies a simple configuration change to reference a _dynamic_ session factory, instead of the default Hibernate SessionFactory.

Here is a list of maven projects and modules to implement the solution:

|| *provision* || This project downloads resources into the maven repository.  The project does not generate any new artifact. ||
|| *hibernate-classes* || Assembles Hibernate classes into a new OSGi bundle ||
|| *jta* || Assembles javax.transaction into a now OSGi bundle ||
|| *hibernate-session* || Provides a Hibernate SessionFactory that can be dynamically reconfigured during runtime - classes be added to, or removed from the Hibernate configuration as bundles are started and stopped.  This bundle exports a service, DynamicConfiguration, which other bundles can use to register their contributions to the SessionFactory.   The bundle also exports a DynamicSessionFactory which should be used to create Hibernate sessions with the most up to date Hibernate configuration.  [More...] ||
|| *model-a* || This bundle contributes an additional class (called "A1") to the Hibernate configuration.  It also provides a DAO service (called "A1Dao") for this class.  ||
|| *integration-tests* || The only way that we currently know if anything is actually happening!  This bundle tests if a dynamically updated Hibernate Session can be used to create, read, update and delete objects of class A1 in the database.  ||
|| *deployment* || This project assembles all dependent bundles along with a (Windows) batch file (called equinox.cmd) and a config.ini file so you can very easily start all the bundles in Equinox. [More...] ||

The following modules are placeholders and are either not implemented, or not used yet.

|| *application-a* || Plan to make an tiny sample application that uses the DAO from model-a ||
|| *application-b* || Plan to make an tiny sample application that uses the DAO from model-b ||
|| *hsqldb* || Downloads and assembles HSQLDB into an OSGi bundle.  The bundle is not used yet, though you could use the assembled artifact to run HSQLDB from the command line ||
|| *model-b* || Plan to add another model class and dao to the sample ||

Not there yet:

|| *application-ab* || Plan to make an tiny sample application that uses the DAO from model-a and model-b ||

= Todo =

 * Use HSQLDB automatically (so user does not have to manually start it)
 * Write docs for the "More..." links above
 * Make model-b
 * Make application-a
 * Make application-b
 * Make application-ab
 * Switch to extender model instead of manual activator model
 * Write docs explaining in more detail what model-a does at startup and shutdown, and also show explicitly what it's Spring configuration is all about.